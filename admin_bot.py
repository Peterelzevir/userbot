# admin_bot.py

from telethon import TelegramClient, events, Button, types
from telethon.tl.functions.users import GetFullUserRequest
from telethon.sessions import StringSession
from telethon.errors import SessionPasswordNeededError, PhoneCodeInvalidError, FloodWaitError
from config import API_ID, API_HASH, BOT_TOKEN, ADMIN_IDS, APP_VERSION
import asyncio
from datetime import datetime, timedelta
import os
import math
import json
import logging
import sys
import re
import subprocess
import signal
from pathlib import Path

# Konfigurasi logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('bot.log'),
        logging.StreamHandler(sys.stdout)
    ]
)
logger = logging.getLogger(__name__)

class UserBotManager:
    def __init__(self):
        self.running_bots = {}  # {user_id: process}
        
    async def start_userbot(self, session_string, api_id, api_hash):
        """Start userbot process"""
        try:
            # Create command to run userbot
            cmd = [
                sys.executable,
                "userbot.py",
                session_string,
                str(api_id),
                api_hash
            ]
            
            # Start process
            process = subprocess.Popen(
                cmd,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE
            )
            
            # Wait a bit to check if process started successfully
            await asyncio.sleep(5)
            
            if process.poll() is None:  # Process still running
                return True, process
            else:
                # Get error if process failed
                _, stderr = process.communicate()
                return False, stderr.decode()
                
        except Exception as e:
            return False, str(e)
            
    def stop_userbot(self, process):
        """Stop userbot process"""
        try:
            process.send_signal(signal.SIGTERM)
            process.wait(timeout=5)
        except:
            process.kill()  # Force kill if graceful shutdown fails

def load_data():
    """Load data from JSON file with error handling"""
    try:
        with open('data.json', 'r', encoding='utf-8') as f:
            data = json.load(f)
            default_data = {
                'userbots': {},
                'premium_users': {},
                'users': {}
            }
            for key, value in default_data.items():
                if key not in data:
                    data[key] = value
            return data
    except FileNotFoundError:
        default_data = {'userbots': {}, 'premium_users': {}, 'users': {}}
        save_data(default_data)
        return default_data
    except json.JSONDecodeError:
        logger.error("Invalid JSON in data.json")
        return {'userbots': {}, 'premium_users': {}, 'users': {}}

def save_data(data):
    """Save data to JSON file with error handling"""
    try:
        with open('data.json', 'w', encoding='utf-8') as f:
            json.dump(data, f, indent=4, ensure_ascii=False)
        return True
    except Exception as e:
        logger.error(f"Error saving data: {str(e)}")
        return False

def is_premium(user_id):
    """Check if user has premium status"""
    data = load_data()
    str_id = str(user_id)
    if str_id in data.get('premium_users', {}):
        try:
            expiry = datetime.fromisoformat(data['premium_users'][str_id]['expires_at'])
            if expiry > datetime.now():
                return True
            else:
                del data['premium_users'][str_id]
                save_data(data)
        except (ValueError, KeyError):
            pass
    return False

def save_user(user_id, username=None):
    """Save new user to database"""
    data = load_data()
    str_id = str(user_id)
    if str_id not in data['users']:
        data['users'][str_id] = {
            'id': user_id,
            'username': username,
            'first_seen': datetime.now().isoformat()
        }
        save_data(data)

async def verify_session(session_str, api_id, api_hash):
    """Verify if a session is valid and working"""
    client = None
    try:
        client = TelegramClient(StringSession(session_str), api_id, api_hash)
        await client.connect()
        
        if not await client.is_user_authorized():
            return False
            
        # Test basic functionality
        me = await client.get_me()
        if not me:
            return False
            
        return True
        
    except Exception as e:
        logger.error(f"Session verification error: {str(e)}")
        return False
    finally:
        if client:
            try:
                await client.disconnect()
            except:
                pass
                
class AdminBot:
    def __init__(self):
        self.bot = TelegramClient('admin_bot', API_ID, API_HASH)
        self.page_size = 10
        self.userbot_manager = UserBotManager()
        self.help_pages = {
            'main': {
                'text': """
üìö **Panduan Penggunaan Bot**

Silahkan pilih kategori bantuan di bawah ini:
                """,
                'buttons': [
                    [Button.inline("ü§ñ Manajemen Userbot", "help_userbot")],
                    [Button.inline("‚öôÔ∏è Pengaturan", "help_settings")],
                    [Button.inline("‚ùå Tutup", "help_close")]
                ]
            },
            'userbot': {
                'text': """
ü§ñ **Panduan Manajemen Userbot**

**Perintah Tersedia:**
‚Ä¢ `/start` - Memulai bot dan membuat userbot baru
‚Ä¢ `/cek` - Mengecek status userbot (Admin)
‚Ä¢ `/hapus` - Menghapus userbot
‚Ä¢ `/help` - Menampilkan bantuan ini
‚Ä¢ `/addpremium` - Menambahkan user premium (Admin)
‚Ä¢ `/broadcast` - Mengirim pesan broadcast (Admin)
‚Ä¢ `/restart` - Restart userbot jika ada masalah

**Perintah Userbot:**
‚Ä¢ `.help` - Menampilkan bantuan userbot
‚Ä¢ `.hiyaok` - Memulai forward pesan
‚Ä¢ `.listgrup` - Melihat daftar grup
‚Ä¢ `.ban` - Ban grup dari forward
‚Ä¢ `.stop` - Menghentikan semua forward

**Catatan:**
‚Ä¢ Semua perintah mendukung awalan `/`, `!`, dan `.`
‚Ä¢ User premium hanya dapat membuat 1 userbot
‚Ä¢ Durasi userbot premium otomatis 30 hari
                """,
                'buttons': [
                    [Button.inline("‚óÄÔ∏è Kembali", "help_main")],
                    [Button.inline("‚ùå Tutup", "help_close")]
                ]
            },
            'settings': {
                'text': """
‚öôÔ∏è **Panduan Pengaturan**

**Fitur:**
‚Ä¢ Toggle status userbot dengan sekali klik
‚Ä¢ Konfirmasi sebelum penghapusan
‚Ä¢ Pembersihan otomatis sesi yang tidak terpakai
‚Ä¢ Pengecekan sesi ganda
‚Ä¢ Manajemen user premium
‚Ä¢ Sistem broadcast pesan
‚Ä¢ Auto-restart userbot

**Tips:**
‚Ä¢ Selalu cek status sebelum membuat userbot baru
‚Ä¢ Backup data secara berkala
‚Ä¢ Monitor masa aktif userbot premium
‚Ä¢ Gunakan /restart jika userbot bermasalah
                """,
                'buttons': [
                    [Button.inline("‚óÄÔ∏è Kembali", "help_main")],
                    [Button.inline("‚ùå Tutup", "help_close")]
                ]
            }
        }

    async def create_new_userbot(self, conv, phone, api_id, api_hash, duration, owner_id):
        """Create new userbot session with enhanced error handling"""
        client = None
        
        try:
            # Validate inputs
            try:
                api_id = int(api_id)
            except ValueError:
                await conv.send_message("‚ùå **Error: API ID harus berupa angka!**")
                return

            # Check if phone number already has a userbot
            data = load_data()
            for bot_info in data['userbots'].values():
                if bot_info['phone'] == phone:
                    await conv.send_message("‚ùå **Error: Nomor telepon ini sudah memiliki userbot!**")
                    return

            # Create client and connect
            client = TelegramClient(StringSession(), api_id, api_hash, device_model=APP_VERSION)
            await client.connect()
            
            await conv.send_message("‚è≥ **Memproses permintaan login...**")

            try:
                code = await client.send_code_request(phone)
            except FloodWaitError as e:
                wait_time = str(timedelta(seconds=e.seconds))
                await conv.send_message(f"‚ùå **Terlalu banyak percobaan! Silahkan tunggu {wait_time} sebelum mencoba lagi.**")
                return
            
            await conv.send_message("""
üì≤ **Masukkan kode OTP**

Format: 1 2 3 4 5 (pisahkan dengan spasi)

‚è≥ Waktu: 5 menit
            """)

            try:
                otp_msg = await conv.get_response(timeout=300)
                otp = ''.join(otp_msg.text.split())
            except asyncio.TimeoutError:
                await conv.send_message("‚ùå **Waktu habis! Silahkan coba lagi.**")
                return

            try:
                await client.sign_in(phone=phone, code=otp, phone_code_hash=code.phone_code_hash)
            except PhoneCodeInvalidError:
                await conv.send_message("‚ùå **Kode OTP tidak valid! Silahkan coba lagi.**")
                return
            
            except SessionPasswordNeededError:
                await conv.send_message("üîê **Akun ini menggunakan verifikasi 2 langkah. Silahkan masukkan password:**")
                
                try:
                    password = await conv.get_response(timeout=300)
                    await client.sign_in(password=password.text)
                except asyncio.TimeoutError:
                    await conv.send_message("‚ùå **Waktu habis! Silahkan coba lagi.**")
                    return
            
            me = await client.get_me()
            session_string = client.session.save()

            # Test if session works
            is_working = await verify_session(session_string, api_id, api_hash)
            if not is_working:
                await conv.send_message("‚ùå **Error: Gagal memverifikasi sesi userbot. Silahkan coba lagi.**")
                return
            
            # Save userbot data
            data = load_data()
            expiry_date = (datetime.now() + timedelta(days=duration)).isoformat()

            data['userbots'][str(me.id)] = {
                'first_name': me.first_name,
                'last_name': me.last_name,
                'phone': phone,
                'created_at': datetime.now().isoformat(),
                'expires_at': expiry_date,
                'active': True,
                'session': session_string,
                'owner_id': owner_id,
                'api_id': api_id,
                'api_hash': api_hash
            }
            
            if save_data(data):
                # Start the userbot
                success, result = await self.userbot_manager.start_userbot(
                    session_string,
                    api_id,
                    api_hash
                )
                
                if not success:
                    error_msg = f"""
‚ùå **Error saat menjalankan userbot:**
`{result}`

Detail userbot tetap tersimpan, gunakan /restart untuk mencoba lagi.
                    """
                    await conv.send_message(error_msg)
                    return
                    
                # Save process
                self.userbot_manager.running_bots[str(me.id)] = result
                
                success_text = f"""
ü§ñ **Userbot berhasil dibuat dan dijalankan!**

üë§ **Detail Userbot:**
‚Ä¢ First Name: `{me.first_name}`
‚Ä¢ Last Name: `{me.last_name or 'N/A'}`
‚Ä¢ User ID: `{me.id}`
‚Ä¢ Phone: `{phone}`
‚Ä¢ Created: `{datetime.now().strftime('%Y-%m-%d %H:%M:%S')}`
‚Ä¢ Expires: `{datetime.fromisoformat(expiry_date).strftime('%Y-%m-%d %H:%M:%S')}`

‚úÖ **Status: Aktif dan Berjalan**

üì± **Perintah Tersedia:**
‚Ä¢ .help - Lihat bantuan
‚Ä¢ .hiyaok - Mulai forward message 
‚Ä¢ .listgrup - Lihat daftar grup
‚Ä¢ .ban - Ban grup dari forward
‚Ä¢ .stop - Stop semua forward

‚ö†Ô∏è **PENTING:**
1. Userbot sudah aktif dan siap digunakan.
2. Simpan informasi di bawah dengan aman.
3. Gunakan .help untuk melihat semua perintah.
4. Jika ada masalah, gunakan /restart.

üìù **String Session (RAHASIAKAN!):**
`{session_string}`

‚ö°Ô∏è **API Credentials:**
‚Ä¢ API ID: `{api_id}`
‚Ä¢ API Hash: `{api_hash}`

üîí **SIMPAN INFORMASI DI ATAS DENGAN AMAN!**
                """
                
                # Send userbot details
                await conv.send_message(success_text)
                
                # Send back to main menu based on owner ID role.
                buttons = [
                    [Button.inline("ü§ñ Buat Userbot", "create_userbot")],
                    [Button.inline("üë• Add Premium", "add_premium")],
                    [Button.inline("üì¢ Broadcast", "broadcast")],
                    [Button.inline("‚ùì Bantuan", "help_main")]
                ] if owner_id in ADMIN_IDS else [
                    [Button.inline("ü§ñ Cek Status", "check_status")],
                    [Button.inline("‚ùì Bantuan", "help_main")]
                ]
                
                await conv.send_message("üëã **Kembali ke menu utama.**", buttons=buttons)
                
            else:
                await conv.send_message("‚ùå **Error saat menyimpan data userbot!**")
            
        except Exception as e:
            await conv.send_message(f"‚ùå **Error tidak terduga:** `{str(e)}`")
        
        finally:
            if client:
                try:
                    await client.disconnect()
                except Exception as e:
                    logger.error(f"Error disconnecting client: {str(e)}")

    async def show_userbot_list(self, event, page=0):
        """Show list of userbots with pagination"""
        data = load_data()
        
        if not data['userbots']:
            await event.reply("‚ùå **Tidak ada userbot yang ditemukan!**")
            return

        userbots = list(data['userbots'].items())
        total_pages = math.ceil(len(userbots) / self.page_size)
        start_idx = page * self.page_size
        end_idx = start_idx + self.page_size
        
        current_page_userbots = userbots[start_idx:end_idx]
        
        buttons = []
        
        for user_id, info in current_page_userbots:
            status = "üü¢" if info['active'] else "üî¥"
            expires = datetime.fromisoformat(info['expires_at'])
            days_left = (expires - datetime.now()).days
            
            is_running = user_id in self.userbot_manager.running_bots
            
            status_text = f"{status} {'‚ö°Ô∏è' if is_running else ''}"
            
            button_text = f"{status_text} {info['first_name']} ({days_left} hari)"
            
            buttons.append([Button.inline(button_text, f"toggle_{user_id}")])
        
        # Add pagination buttons if necessary 
        nav_buttons = []
        if page > 0:
            nav_buttons.append(Button.inline("‚¨ÖÔ∏è Kembali", f"page_{page-1}"))
        if page < total_pages - 1:
            nav_buttons.append(Button.inline("Lanjut ‚û°Ô∏è", f"page_{page+1}"))
        if nav_buttons:
            buttons.append(nav_buttons)

        buttons.append([Button.inline("‚ùì Bantuan", "help_main")])

        active_count = sum(1 for _, info in data['userbots'].items() if info['active'])
        inactive_count = len(data['userbots']) - active_count
        running_count = len(self.userbot_manager.running_bots)
        premium_count = sum(1 for _, info in data['premium_users'].items() if datetime.fromisoformat(info['expires_at']) > datetime.now())
        
        text = f"""
üìä **Statistik Bot:**
‚Ä¢ Total Userbot: `{len(data['userbots'])}`
‚Ä¢ Userbot Aktif: `{active_count}`
‚Ä¢ Userbot Berjalan: `{running_count}`
‚Ä¢ Userbot Nonaktif: `{inactive_count}`
‚Ä¢ User Premium: `{premium_count}`

üîÑ **Daftar Userbot:**
Status: üü¢ Aktif | üî¥ Nonaktif | ‚ö°Ô∏è Berjalan
Klik status untuk mengubah aktif/nonaktif
        """
        
        if event.message:
            await event.reply(text, buttons=buttons)
        else:
            await event.edit(text, buttons=buttons)

    async def show_delete_list(self, event, page=0):
        """Show list of userbots for deletion"""
        data = load_data()
        
        if not data['userbots']:
            await event.reply("‚ùå **Tidak ada userbot yang ditemukan!**")
            return
            
        text = """
‚ùå **Hapus Userbot**

Silahkan pilih userbot yang ingin dihapus:
‚Ä¢ Klik pada userbot untuk konfirmasi
‚Ä¢ Proses tidak dapat dibatalkan
        """
        
        userbots = list(data['userbots'].items())
        total_pages = math.ceil(len(userbots) / self.page_size)
        start_idx = page * self.page_size
        end_idx = start_idx + self.page_size
        current_page_userbots = userbots[start_idx:end_idx]

        buttons = []
        for user_id, info in current_page_userbots:
            status = "üü¢" if info['active'] else "üî¥"
            expires = datetime.fromisoformat(info['expires_at'])
            days_left = (expires - datetime.now()).days
            is_running = user_id in self.userbot_manager.running_bots
            status_text = f"{status} {'‚ö°Ô∏è' if is_running else ''}"
            button_text = f"{status_text} {info['first_name']} ({days_left} hari)"
            buttons.append([Button.inline(button_text, f"delete_{user_id}")])

        nav_buttons = []
        if page > 0:
            nav_buttons.append(Button.inline("‚¨ÖÔ∏è Kembali", f"delete_page_{page-1}"))
        if page < total_pages - 1:
            nav_buttons.append(Button.inline("Lanjut ‚û°Ô∏è", f"delete_page_{page+1}"))
        if nav_buttons:
            buttons.append(nav_buttons)

        buttons.append([Button.inline("‚ùå Tutup", "help_close")])

        if event.message:
            await event.reply(text, buttons=buttons)
        else:
            await event.edit(text, buttons=buttons)

    async def start(self):
        """Start the bot and register all handlers"""
        
        @self.bot.on(events.NewMessage(pattern=r'(?i)[!/\.]start$'))
        async def start_handler(event):
            user_id = event.sender_id
            save_user(user_id, event.sender.username)
            
            if user_id in ADMIN_IDS:
                buttons = [
                    [Button.inline("ü§ñ Buat Userbot", "create_userbot")],
                    [Button.inline("üë• Add Premium", "add_premium")],
                    [Button.inline("üì¢ Broadcast", "broadcast")],
                    [Button.inline("‚ùì Bantuan", "help_main")]
                ]
                await event.reply("""
üëã **Selamat datang Admin!**

Silahkan pilih menu yang tersedia:
‚Ä¢ Buat Userbot - Membuat userbot baru
‚Ä¢ Add Premium - Menambah user premium
‚Ä¢ Broadcast - Kirim pesan ke semua user
‚Ä¢ Bantuan - Panduan penggunaan bot

‚ö°Ô∏è Status: Sistem berjalan normal
                """, buttons=buttons)
                return

            if is_premium(user_id):
                text = """
üëã **Selamat datang User Premium!**

Silahkan pilih menu yang tersedia:
‚Ä¢ Buat Userbot - Membuat userbot premium
‚Ä¢ Bantuan - Panduan penggunaan bot

‚ú® Premium benefits:
‚Ä¢ Userbot premium 30 hari
‚Ä¢ Fitur autoforward
‚Ä¢ Support prioritas
‚Ä¢ Update otomatis
                """
                buttons = [
                    [Button.inline("ü§ñ Buat Userbot", "create_userbot")],
                    [Button.inline("‚ùì Bantuan", "help_main")]
                ]
            else:
                text = """
üëã **Selamat datang!**

üîí Untuk membuat userbot, Anda memerlukan akses premium.

üì¶ **Keuntungan Premium:**
‚Ä¢ Buat userbot pribadi
‚Ä¢ Durasi aktif 30 hari
‚Ä¢ Fitur autoforward
‚Ä¢ Support prioritas
‚Ä¢ Update otomatis
‚Ä¢ Garansi puas

üíé **Harga Paket Premium:**
‚Ä¢ 1 Bulan: Rp XX.XXX
‚Ä¢ 3 Bulan: Rp XX.XXX
‚Ä¢ 6 Bulan: Rp XX.XXX
‚Ä¢ 1 Tahun: Rp XX.XXX

‚ú® **Bonus Premium:**
‚Ä¢ Setup gratis
‚Ä¢ Panduan lengkap
‚Ä¢ Konsultasi 24/7
‚Ä¢ Backup otomatis

üëâ **Cara Berlangganan:**
1. Hubungi admin @admin
2. Pilih paket premium
3. Lakukan pembayaran
4. Dapatkan akses instant!
                """
                buttons = [
                    [Button.url("üí¨ Chat Admin", "https://t.me/admin")],
                    [Button.inline("‚ùì Bantuan", "help_main")]
                ]

            await event.reply(text, buttons=buttons)
            
            @self.bot.on(events.CallbackQuery(pattern=r'^help_(\w+)'))
        async def help_callback(event):
            page = event.data.decode().split('_')[1]
            if page == 'close':
                await event.delete()
                return

            help_page = self.help_pages.get(page, self.help_pages['main'])
            await event.edit(help_page['text'], buttons=help_page['buttons'])

        @self.bot.on(events.CallbackQuery(pattern="broadcast"))
        async def broadcast_button_handler(event):
            if event.sender_id not in ADMIN_IDS:
                await event.answer("‚ö†Ô∏è Hanya untuk admin!", alert=True)
                return

            async with self.bot.conversation(event.chat_id) as conv:
                try:
                    await event.delete()
                    await conv.send_message("""
üì¢ **Menu Broadcast**

Silahkan kirim pesan yang ingin di-broadcast.
Format didukung: Text, Markdown

Note: 
‚Ä¢ Pesan akan dikirim ke semua user
‚Ä¢ Tunggu hingga proses selesai
‚Ä¢ Jangan kirim pesan lain saat proses
                    """)
                    msg = await conv.get_response(timeout=300)
                    
                    data = load_data()
                    success = 0
                    failed = 0
                    
                    progress_msg = await conv.send_message("üì§ **Memulai broadcast...**")
                    
                    total_users = len(data['users'])
                    for i, (user_id, _) in enumerate(data['users'].items(), 1):
                        try:
                            await self.bot.send_message(int(user_id), msg.text, parse_mode='md')
                            success += 1
                        except Exception as e:
                            logger.error(f"Broadcast error for {user_id}: {str(e)}")
                            failed += 1
                            continue
                        
                        if i % 5 == 0:  # Update progress every 5 users
                            await progress_msg.edit(f"üì§ **Mengirim broadcast... ({i}/{total_users})**")
                        await asyncio.sleep(0.5)  # Delay to prevent flood

                    await progress_msg.edit(f"""
‚úÖ **Broadcast selesai!**

üìä **Statistik Pengiriman:**
‚Ä¢ Berhasil: `{success} user`
‚Ä¢ Gagal: `{failed} user`
‚Ä¢ Total: `{success + failed} user`
‚Ä¢ Success Rate: `{(success/(success+failed))*100:.1f}%`

‚ö†Ô∏è Gagal terkirim biasanya karena:
‚Ä¢ User memblokir bot
‚Ä¢ User menghapus chat
‚Ä¢ Error jaringan
                    """)
                    
                    # Back to admin menu
                    buttons = [
                        [Button.inline("ü§ñ Buat Userbot", "create_userbot")],
                        [Button.inline("üë• Add Premium", "add_premium")],
                        [Button.inline("üì¢ Broadcast", "broadcast")],
                        [Button.inline("‚ùì Bantuan", "help_main")]
                    ]
                    await conv.send_message("üëã **Kembali ke menu admin.**", buttons=buttons)
                    
                except asyncio.TimeoutError:
                    await conv.send_message("""
‚ùå **Waktu habis!**

Silahkan klik tombol broadcast untuk mencoba lagi.
                    """)

        @self.bot.on(events.CallbackQuery(pattern="check_status"))
        async def check_status_callback(event):
            """Handle check status button for premium users"""
            user_id = event.sender_id
            
            if not is_premium(user_id):
                return await not_premium_handler(event)
                
            data = load_data()
            user_bot = None
            for bot_id, info in data['userbots'].items():
                if str(info.get('owner_id')) == str(user_id):
                    user_bot = (bot_id, info)
                    break
                    
            if user_bot:
                bot_id, info = user_bot
                expires = datetime.fromisoformat(info['expires_at'])
                days_left = (expires - datetime.now()).days
                is_running = bot_id in self.userbot_manager.running_bots
                
                text = f"""
ü§ñ **Status Userbot Anda**

üë§ **Detail Userbot:**
‚Ä¢ Nama: `{info['first_name']}`
‚Ä¢ Status: {"üü¢ Aktif" if info['active'] else "üî¥ Nonaktif"} {"‚ö°Ô∏è (Berjalan)" if is_running else ""}
‚Ä¢ Nomor: `{info['phone']}`
‚Ä¢ Dibuat: `{datetime.fromisoformat(info['created_at']).strftime('%Y-%m-%d %H:%M:%S')}`
‚Ä¢ Kadaluarsa: `{datetime.fromisoformat(info['expires_at']).strftime('%Y-%m-%d %H:%M:%S')}`
‚Ä¢ Sisa Durasi: {days_left} hari

üì± **Perintah Tersedia:**
‚Ä¢ .help - Lihat panduan
‚Ä¢ .hiyaok - Forward pesan
‚Ä¢ .listgrup - Lihat grup
‚Ä¢ .stop - Stop forward

üí° **Tips:**
‚Ä¢ Gunakan /restart jika ada masalah
‚Ä¢ Hubungi admin untuk perpanjang durasi
‚Ä¢ Backup string session dengan aman
                """
                buttons = [[Button.inline("‚óÄÔ∏è Kembali", "back_to_start")]]
                await event.edit(text, buttons=buttons)
            else:
                await event.answer("‚ùå Anda belum memiliki userbot!", alert=True)
                await not_premium_handler(event)

        @self.bot.on(events.CallbackQuery(pattern="add_premium"))
        async def premium_button_handler(event):
            if event.sender_id not in ADMIN_IDS:
                await event.answer("‚ö†Ô∏è Hanya untuk admin!", alert=True)
                return

     async with self.bot.conversation(event.chat_id) as conv:
                try:
                    await event.delete()
                    await conv.send_message("""
üë• **Menu Add Premium User**

Silahkan ikuti langkah berikut:
1. Masukkan ID user yang akan ditambahkan
2. Masukkan durasi premium dalam hari

Note:
‚Ä¢ ID user bisa didapat dari @userinfobot
‚Ä¢ Durasi minimal 1 hari
‚Ä¢ User akan mendapat notifikasi otomatis
                    """)
                    
                    await conv.send_message("üìù **Masukkan ID user yang akan ditambahkan sebagai premium:**")
                    user_id_msg = await conv.get_response(timeout=300)
                    user_id = user_id_msg.text.strip()
                    
                    try:
                        user_id = int(user_id)
                    except ValueError:
                        await conv.send_message("‚ùå **Error: User ID harus berupa angka!**")
                        return
                    
                    # Check if already premium
                    if is_premium(user_id):
                        await conv.send_message("‚ö†Ô∏è **User sudah memiliki akses premium!**")
                        return
                    
                    await conv.send_message("""
‚è≥ **Masukkan durasi premium dalam hari**

Contoh durasi:
‚Ä¢ 30 = 1 bulan
‚Ä¢ 90 = 3 bulan
‚Ä¢ 180 = 6 bulan
‚Ä¢ 365 = 1 tahun
                    """)
                    duration_msg = await conv.get_response(timeout=300)
                    try:
                        duration = int(duration_msg.text.strip())
                        if duration < 1:
                            raise ValueError("Durasi minimal 1 hari")
                    except ValueError:
                        await conv.send_message("‚ùå **Error: Durasi harus berupa angka positif!**")
                        return
                    
                    data = load_data()
                    expiry_date = (datetime.now() + timedelta(days=duration)).isoformat()
                    
                    # Check if user exists
                    try:
                        user = await self.bot.get_entity(user_id)
                        if not user:
                            raise ValueError("User tidak ditemukan")
                    except Exception as e:
                        await conv.send_message("‚ùå **Error: User tidak ditemukan di Telegram!**")
                        return
                    
                    data['premium_users'][str(user_id)] = {
                        'added_at': datetime.now().isoformat(),
                        'expires_at': expiry_date,
                        'added_by': event.sender_id,
                        'username': user.username,
                        'first_name': user.first_name
                    }
                    
                    if save_data(data):
                        # Notify user
                        try:
                            text = f"""
üéâ **Selamat! Anda telah mendapatkan akses premium!**

üìÖ **Detail Premium:**
‚Ä¢ Tanggal Mulai: `{datetime.now().strftime('%Y-%m-%d %H:%M:%S')}`
‚Ä¢ Kadaluarsa: `{datetime.fromisoformat(expiry_date).strftime('%Y-%m-%d %H:%M:%S')}`
‚Ä¢ Durasi: `{duration} hari`

‚ú® **Fitur Premium:**
‚Ä¢ Buat userbot pribadi
‚Ä¢ Fitur autoforward 
‚Ä¢ Support prioritas
‚Ä¢ Update otomatis
‚Ä¢ Dan lainnya...

üì± **Cara Mulai:**
1. Kirim /start ke bot
2. Klik tombol "Buat Userbot"
3. Ikuti instruksi selanjutnya

üí° **Tips:**
‚Ä¢ Simpan pesan ini untuk referensi
‚Ä¢ Hubungi admin jika butuh bantuan
‚Ä¢ Backup semua data penting

Selamat menggunakan fitur premium! 
                            """
                            await self.bot.send_message(user_id, text)
                            await conv.send_message(f"""
‚úÖ **Berhasil menambahkan user premium!**

üë§ **Detail User:**
‚Ä¢ ID: `{user_id}`
‚Ä¢ Username: @{user.username or "None"}
‚Ä¢ Nama: {user.first_name}
‚Ä¢ Durasi: {duration} hari
‚Ä¢ Expires: {datetime.fromisoformat(expiry_date).strftime('%Y-%m-%d %H:%M:%S')}

‚ú® User telah dinotifikasi via bot
                            """)
                            
                            # Send back to admin menu
                            buttons = [
                                [Button.inline("ü§ñ Buat Userbot", "create_userbot")],
                                [Button.inline("üë• Add Premium", "add_premium")],
                                [Button.inline("üì¢ Broadcast", "broadcast")],
                                [Button.inline("‚ùì Bantuan", "help_main")]
                            ]
                            await conv.send_message("üëã **Kembali ke menu admin.**", buttons=buttons)
                            
                        except Exception as e:
                            logger.error(f"Error notifying premium user: {str(e)}")
                            await conv.send_message(f"""
‚ö†Ô∏è **Berhasil menambahkan premium, tapi gagal mengirim notifikasi ke user**

Error: `{str(e)}`
Mohon informasikan manual ke user.
                            """)
                    else:
                        await conv.send_message("‚ùå **Gagal menyimpan data premium user!**")
                    
                except asyncio.TimeoutError:
                    await conv.send_message("‚ùå **Waktu habis! Silahkan klik tombol Add Premium untuk mencoba lagi.**")
                except Exception as e:
                    logger.error(f"Error adding premium user: {str(e)}")
                    await conv.send_message(f"‚ùå **Error tidak terduga:** `{str(e)}`")
                    
                    @self.bot.on(events.CallbackQuery(pattern="not_premium"))
        async def not_premium_handler(event):
            text = """
‚ö†Ô∏è **Akses Premium Diperlukan!**

Untuk membuat userbot, Anda memerlukan akses premium.

üì¶ **Keuntungan Premium:**
‚Ä¢ Buat userbot pribadi
‚Ä¢ Durasi aktif 30 hari
‚Ä¢ Fitur autoforward
‚Ä¢ Support prioritas
‚Ä¢ Update otomatis
‚Ä¢ Garansi kepuasan

üíé **Harga Paket Premium:**
‚Ä¢ 1 Bulan: Rp XX.XXX
‚Ä¢ 3 Bulan: Rp XX.XXX 
‚Ä¢ 6 Bulan: Rp XX.XXX
‚Ä¢ 1 Tahun: Rp XX.XXX

üéÅ **Bonus Premium:**
‚Ä¢ Setup gratis
‚Ä¢ Panduan lengkap 
‚Ä¢ Konsultasi 24/7
‚Ä¢ Backup otomatis

üëâ **Cara Berlangganan:**
1. Hubungi admin @admin
2. Pilih paket premium
3. Lakukan pembayaran 
4. Dapatkan akses instant!

‚ú® Upgrade sekarang dan nikmati semua fitur premium!
            """
            buttons = [
                [Button.url("üí¨ Chat Admin", "https://t.me/admin")],
                [Button.inline("‚óÄÔ∏è Kembali ke Menu", "back_to_start")]
            ]
            await event.edit(text, buttons=buttons)

        @self.bot.on(events.CallbackQuery(pattern=r'^create_userbot$'))
        async def create_userbot_handler(event):
            user_id = event.sender_id
            
            if user_id not in ADMIN_IDS:
                if not is_premium(user_id):
                    await event.answer("‚ö†Ô∏è Anda harus premium untuk membuat userbot!", alert=True)
                    return await not_premium_handler(event)
                
                data = load_data()
                for info in data['userbots'].values():
                    if str(info.get('owner_id')) == str(user_id):
                        text = f"""
‚ö†Ô∏è **Anda sudah memiliki userbot!**

ü§ñ **Detail Userbot:**
‚Ä¢ Nama: `{info['first_name']}`
‚Ä¢ Status: {"üü¢ Aktif" if info['active'] else "üî¥ Nonaktif"}
‚Ä¢ Dibuat: `{datetime.fromisoformat(info['created_at']).strftime('%Y-%m-%d %H:%M:%S')}`
‚Ä¢ Kadaluarsa: `{datetime.fromisoformat(info['expires_at']).strftime('%Y-%m-%d %H:%M:%S')}`
‚Ä¢ Running: {"‚ö°Ô∏è Ya" if str(user_id) in self.userbot_manager.running_bots else "‚ùå Tidak"}

üì± **Perintah Tersedia:**
‚Ä¢ /restart - Restart userbot
‚Ä¢ .help - Lihat panduan lengkap
‚Ä¢ .stop - Stop semua tugas

üí° **Tips:**
‚Ä¢ Gunakan /restart jika userbot error
‚Ä¢ Hubungi admin jika butuh bantuan
                        """
                        buttons = [[Button.inline("‚óÄÔ∏è Kembali", "back_to_start")]]
                        await event.edit(text, buttons=buttons)
                        return

            async with self.bot.conversation(event.chat_id) as conv:
                try:
                    await event.delete()
                    await conv.send_message("""
üì± **Form Pembuatan Userbot**

Silahkan ikuti langkah-langkah berikut:

1Ô∏è‚É£ Kunjungi my.telegram.org
2Ô∏è‚É£ Login dengan nomor telepon
3Ô∏è‚É£ Klik API Development Tools
4Ô∏è‚É£ Buat aplikasi baru untuk mendapat API ID & Hash

‚ö†Ô∏è **PENTING:**
‚Ä¢ API ID berupa angka (contoh: 1234567)
‚Ä¢ API Hash berupa huruf & angka
‚Ä¢ Nomor telepon format: +628xxx
‚Ä¢ Jangan bagikan API ID & Hash
‚Ä¢ Simpan informasi dengan aman

Kirim /cancel untuk membatalkan
                    """)
                    
                    await conv.send_message("üìù **Masukkan API ID:**")
                    api_id_msg = await conv.get_response(timeout=300)
                    
                    # Check for cancel
                    if api_id_msg.text.lower() == "/cancel":
                        await conv.send_message("‚ùå Pembuatan userbot dibatalkan.")
                        return
                        
                    api_id = api_id_msg.text.strip()

                    await conv.send_message("üìù **Masukkan API Hash:**")
                    api_hash_msg = await conv.get_response(timeout=300)
                    
                    if api_hash_msg.text.lower() == "/cancel":
                        await conv.send_message("‚ùå Pembuatan userbot dibatalkan.")
                        return
                        
                    api_hash = api_hash_msg.text.strip()

                    await conv.send_message("üì± **Masukkan nomor telepon (format: +628xxx):**")
                    phone_msg = await conv.get_response(timeout=300)
                    
                    if phone_msg.text.lower() == "/cancel":
                        await conv.send_message("‚ùå Pembuatan userbot dibatalkan.") 
                        return
                        
                    phone = phone_msg.text.strip()
                    
                    # Validate phone number format
                    if not re.match(r'^\+\d{10,15}$', phone):
                        await conv.send_message("""
‚ùå **Format nomor telepon tidak valid!**

‚úÖ Format yang benar: +628xxx
‚ùå Format yang salah: 
‚Ä¢ 08xxx (tanpa +)
‚Ä¢ 628xxx (tanpa +)
‚Ä¢ +62-8xxx (ada tanda -)
                        """)
                        return

                    # Set duration based on user type
                    duration = 30 if user_id not in ADMIN_IDS else None
                    if duration is None:
                        await conv.send_message("""
‚è≥ **Masukkan durasi aktif userbot (dalam hari)**

Contoh durasi:
‚Ä¢ 30 = 1 bulan
‚Ä¢ 90 = 3 bulan
‚Ä¢ 180 = 6 bulan
‚Ä¢ 365 = 1 tahun
                        """)
                        duration_msg = await conv.get_response(timeout=300)
                        
                        if duration_msg.text.lower() == "/cancel":
                            await conv.send_message("‚ùå Pembuatan userbot dibatalkan.")
                            return
                            
                        try:
                            duration = int(duration_msg.text.strip())
                            if duration < 1:
                                raise ValueError("Durasi minimal 1 hari")
                        except ValueError:
                            await conv.send_message("‚ùå **Error: Durasi harus berupa angka positif!**")
                            return

                    # Create userbot
                    await self.create_new_userbot(conv, phone, api_id, api_hash, duration, user_id)
                    
                except asyncio.TimeoutError:
                    await conv.send_message("""
‚ùå **Waktu habis!**

Silahkan kirim `/start` untuk memulai ulang proses pembuatan userbot.
                    """)
                except Exception as e:
                    logger.error(f"Error in create_userbot_handler: {str(e)}")
                    await conv.send_message(f"""
‚ùå **Error tidak terduga!**

Detail error: `{str(e)}`
Silahkan hubungi admin untuk bantuan.
                    """)

        @self.bot.on(events.NewMessage(pattern=r'(?i)[!/\.]cek$'))
        async def check_userbot_handler(event):
            user_id = event.sender_id
            
            if user_id not in ADMIN_IDS:
                # For premium users, only show their userbot
                if is_premium(user_id):
                    data = load_data()
                    user_bot = None
                    for bot_id, info in data['userbots'].items():
                        if str(info.get('owner_id')) == str(user_id):
                            user_bot = (bot_id, info)
                            break
                            
                    if user_bot:
                        bot_id, info = user_bot
                        expires = datetime.fromisoformat(info['expires_at'])
                        days_left = (expires - datetime.now()).days
                        is_running = bot_id in self.userbot_manager.running_bots
                        
                        text = f"""
ü§ñ **Status Userbot Anda**

üë§ **Detail:**
‚Ä¢ Nama: `{info['first_name']}`
‚Ä¢ Status: {"üü¢ Aktif" if info['active'] else "üî¥ Nonaktif"} {"‚ö°Ô∏è (Berjalan)" if is_running else ""}
‚Ä¢ Nomor: `{info['phone']}`
‚Ä¢ Dibuat: `{datetime.fromisoformat(info['created_at']).strftime('%Y-%m-%d %H:%M:%S')}`
‚Ä¢ Kadaluarsa: `{datetime.fromisoformat(info['expires_at']).strftime('%Y-%m-%d %H:%M:%S')}`
‚Ä¢ Sisa Durasi: {days_left} hari

üí° **Tips:**
‚Ä¢ Gunakan /restart jika ada masalah
‚Ä¢ Hubungi admin untuk perpanjang durasi
                        """
                        buttons = [[Button.inline("‚óÄÔ∏è Kembali", "back_to_start")]]
                        await event.reply(text, buttons=buttons)
                    else:
                        await event.reply("‚ùå **Anda belum memiliki userbot!**")
                else:
                    return await not_premium_handler(event)
                return
                
            # For admin, show all userbots
            await self.show_userbot_list(event, page=0)

        @self.bot.on(events.CallbackQuery(pattern=r'^page_(\d+)'))
        async def page_callback(event):
            if event.sender_id not in ADMIN_IDS:
                await event.answer("‚ö†Ô∏è Hanya untuk admin!", alert=True)
                return
                
            page = int(event.data.decode().split('_')[1])
            await self.show_userbot_list(event, page)

        @self.bot.on(events.CallbackQuery(pattern="back_to_start"))
        async def back_to_start_handler(event):
            """Handle back to start button"""
            await event.delete()
            # Simulate /start command
            message = event.original_update.msg_id
            await start_handler(await event.get_message())

        # Cleanup expired userbots periodically
        async def cleanup_expired():
            while True:
                try:
                    data = load_data()
                    now = datetime.now()
                    expired = []
                    
                    # Check expired userbots
                    for user_id, info in data['userbots'].items():
                        try:
                            expiry = datetime.fromisoformat(info['expires_at'])
                            if expiry < now:
                                expired.append(user_id)
                                
                                # Stop process if running
                                if user_id in self.userbot_manager.running_bots:
                                    process = self.userbot_manager.running_bots[user_id]
                                    self.userbot_manager.stop_userbot(process)
                                    del self.userbot_manager.running_bots[user_id]
                                
                                # Notify owner
                                try:
                                    owner_id = int(info['owner_id'])
                                    text = f"""
‚ö†Ô∏è **Pemberitahuan Userbot**

ü§ñ **Userbot Anda telah kadaluarsa!**

Detail Userbot:
‚Ä¢ Nama: `{info['first_name']}`
‚Ä¢ Phone: `{info['phone']}`
‚Ä¢ Status: Nonaktif (Expired)

Silahkan hubungi admin untuk perpanjang durasi.
                                    """
                                    await self.bot.send_message(owner_id, text)
                                except:
                                    pass
                        except (ValueError, KeyError):
                            continue
                    
                    if expired:
                        # Remove expired userbots
                        for user_id in expired:
                            del data['userbots'][user_id]
                        save_data(data)
                        logger.info(f"Cleaned up {len(expired)} expired userbots")
                        
                except Exception as e:
                    logger.error(f"Error in cleanup: {str(e)}")
                    
                await asyncio.sleep(3600)  # Check every hour
